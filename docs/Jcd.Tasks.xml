<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Jcd.Tasks</name>
    </assembly>
    <members>
        <member name="T:Jcd.Tasks.BlockingTaskProcessor">
            <summary>
            In a background task, this class starts enqueued tasks in the order they were enqueued,
            waiting for each to complete before executing the next.
            </summary>
            <remarks>
            Ensure all shared resources for the enqueued actions/functions have their access synchronized
            appropriately.
            </remarks>
        </member>
        <member name="P:Jcd.Tasks.BlockingTaskProcessor.QueueLength">
            <summary>
            The number of pending commands.
            </summary>
        </member>
        <member name="M:Jcd.Tasks.BlockingTaskProcessor.#ctor(System.Boolean)">
            <summary>
            Constructs a <see cref="T:Jcd.Tasks.BlockingTaskProcessor"/>
            </summary>
            <param name="autoStart"></param>
        </member>
        <member name="M:Jcd.Tasks.BlockingTaskProcessor.EnqueueAction(System.Action)">
            <summary>
            Enqueues a command for sequential execution. This is a "fire and forget" method.
            Control is returned to the caller immediately.
            </summary>
            <param name="command">The command to execute.</param>
        </member>
        <member name="M:Jcd.Tasks.BlockingTaskProcessor.EnqueueAsyncAction(System.Func{System.Threading.Tasks.Task})">
            <summary>
            Enqueues an async command for sequential execution. This is a "fire and forget" method.
            Control is returned to the caller immediately.
            </summary>
            <param name="command">The asynchronous command to execute.</param>
        </member>
        <member name="M:Jcd.Tasks.BlockingTaskProcessor.EnqueueActionAsync(System.Action)">
            <summary>
            Enqueues a command for sequential execution. Awaiting the returned <see cref="T:System.Threading.Tasks.Task"/>
            waits for the command to finish executing.
            </summary>
            <param name="command">The command to execute.</param>
            <returns>The <see cref="T:System.Threading.Tasks.Task"/> that will execute the enqueued action.</returns>
            <remarks>
            Awaiting this task before <see cref="M:Jcd.Tasks.BlockingTaskProcessor.StartProcessing"/> is called will cause the calling
            thread of execution to block until <see cref="M:Jcd.Tasks.BlockingTaskProcessor.StartProcessing"/> is called. Ensure that
            either <see cref="M:Jcd.Tasks.BlockingTaskProcessor.StartProcessing"/> has already been called, or that your program has
            a mechanism in another thread to call <see cref="M:Jcd.Tasks.BlockingTaskProcessor.StartProcessing"/>. You really need to
            call <see cref="M:Jcd.Tasks.BlockingTaskProcessor.StartProcessing"/> for awaiting the result to work.
            </remarks>
        </member>
        <member name="M:Jcd.Tasks.BlockingTaskProcessor.EnqueueAsyncActionAsync(System.Func{System.Threading.Tasks.Task})">
            <summary>
            Asynchronously enqueues an async command for sequential execution. Awaiting the
            returned <see cref="T:System.Threading.Tasks.Task"/> waits for the command to finish executing.
            </summary>
            <param name="command">The command to execute.</param>
            <returns>The <see cref="T:System.Threading.Tasks.Task`1"/> that will execute the enqueued action.</returns>
            <remarks>
            Awaiting this task before <see cref="M:Jcd.Tasks.BlockingTaskProcessor.StartProcessing"/> is called will cause the calling
            thread of execution to block until <see cref="M:Jcd.Tasks.BlockingTaskProcessor.StartProcessing"/> is called. Ensure that
            either <see cref="M:Jcd.Tasks.BlockingTaskProcessor.StartProcessing"/> has already been called, or that your program has
            a mechanism in another thread to call <see cref="M:Jcd.Tasks.BlockingTaskProcessor.StartProcessing"/>. You really need to
            call <see cref="M:Jcd.Tasks.BlockingTaskProcessor.StartProcessing"/> for awaiting the result to work.
            </remarks>
        </member>
        <member name="M:Jcd.Tasks.BlockingTaskProcessor.EnqueueFunc``1(System.Func{``0})">
            <summary>
            Enqueues a command for sequential execution. This is a "fire and forget" method.
            The command result will not be available and control is returned to the caller immediately.
            </summary>
            <param name="command">The command to execute.</param>
        </member>
        <member name="M:Jcd.Tasks.BlockingTaskProcessor.EnqueueAsyncFunc``1(System.Func{System.Threading.Tasks.Task{``0}})">
            <summary>
            Enqueues an async command for sequential execution. This is a "fire and forget" method.
            The function call result will not be available and control is returned to the caller immediately.
            </summary>
            <param name="command">The async command to execute.</param>
        </member>
        <member name="M:Jcd.Tasks.BlockingTaskProcessor.EnqueueFuncAsync``1(System.Func{``0})">
            <summary>
            Asynchronously enqueues a command for sequential execution. The result of the function
            execution is available by awaiting the returned <see cref="T:System.Threading.Tasks.Task`1"/>
            </summary>
            <param name="command">The command to execute.</param>
            <typeparam name="TResult">The data type returned by the function</typeparam>
            <returns>The <see cref="T:System.Threading.Tasks.Task`1"/> that will execute the enqueued action, once dequeued.</returns>
            <remarks>
            Awaiting this task before <see cref="M:Jcd.Tasks.BlockingTaskProcessor.StartProcessing"/> is called will cause the calling
            thread of execution to block until <see cref="M:Jcd.Tasks.BlockingTaskProcessor.StartProcessing"/> is called. Ensure that
            either <see cref="M:Jcd.Tasks.BlockingTaskProcessor.StartProcessing"/> has already been called, or that your program has
            a mechanism in another thread to call <see cref="M:Jcd.Tasks.BlockingTaskProcessor.StartProcessing"/>. You really need to
            call <see cref="M:Jcd.Tasks.BlockingTaskProcessor.StartProcessing"/> for awaiting the result to work.
            </remarks>
        </member>
        <member name="M:Jcd.Tasks.BlockingTaskProcessor.EnqueueAsyncFuncAsync``1(System.Func{System.Threading.Tasks.Task{``0}})">
            <summary>
            Asynchronously enqueues an async function for sequential execution. The result of the function execution
            is available by awaiting the returned <see cref="T:System.Threading.Tasks.Task`1"/>
            </summary>
            <param name="asyncFunction">The async function to execute.</param>
            <typeparam name="TResult">The data type returned by the function</typeparam>
            <returns>The <see cref="T:System.Threading.Tasks.Task`1"/> that will execute the enqueued action.</returns>
            <remarks>
            Awaiting this task before <see cref="M:Jcd.Tasks.BlockingTaskProcessor.StartProcessing"/> is called will cause the calling
            thread of execution to block until <see cref="M:Jcd.Tasks.BlockingTaskProcessor.StartProcessing"/> is called. Ensure that
            either <see cref="M:Jcd.Tasks.BlockingTaskProcessor.StartProcessing"/> has already been called, or that your program has
            a mechanism in another thread to call <see cref="M:Jcd.Tasks.BlockingTaskProcessor.StartProcessing"/>. You really need to
            call <see cref="M:Jcd.Tasks.BlockingTaskProcessor.StartProcessing"/> for awaiting the result to work.
            </remarks>
        </member>
        <member name="M:Jcd.Tasks.BlockingTaskProcessor.TryEnqueueTask``1(System.Threading.Tasks.Task{``0},System.Boolean@)">
            <summary>
            Tries to enqueues a task for later execution. If the passed in task is not unstarted, it's not enqueued.
            </summary>
            <param name="task">the unstarted task</param>
            <param name="enqueued">a flag indicating if the task was actually enqueued</param>
            <typeparam name="T">The result type of the task.</typeparam>
            <returns>The passed in task, or a cancelled <see cref="T:System.Threading.Tasks.Task`1"/> if the passed in task is null.</returns>
            <remarks>
            <para>
            When passing in a previously started task the task is returned so that you can still await the result
            of the associated action. This is to support framework builders who may not control
            if a task is started or not.
            </para>
            <para>
            The reason for not enqueuing is to prevent such tasks, which can't be started, from
            occupying a position in the execution queue. This allows the processor to get to actual
            unstarted tasks sooner.
            </para>
            </remarks>
        </member>
        <member name="M:Jcd.Tasks.BlockingTaskProcessor.TryEnqueueTask(System.Threading.Tasks.Task,System.Boolean@)">
            <summary>
            Tries to enqueues a task for later execution. If the passed in task is already started, it's not enqueued.
            </summary>
            <param name="task">the unstarted task</param>
            <param name="enqueued">a flag indicating if the task was actually enqueued.</param>
            <returns>The passed in task, or a cancelled <see cref="T:System.Threading.Tasks.Task"/> if the passed in task is null.</returns>
            <remarks>
            <para>
            When passing in a previously started task the task is still returned so that you can still await the result
            of the associated action. This is to support framework builders who may not control
            if a task is unstarted or not.
            </para>
            <para>
            The reason for not enqueuing is to prevent such tasks, which can't be started, from
            occupying a position in the execution queue. This allows the processor to get to actual
            unstarted tasks sooner.
            </para>
            </remarks>
        </member>
        <member name="P:Jcd.Tasks.BlockingTaskProcessor.HasTasks">
            <summary>
            Gets a flag indicating if there are any pending tasks.
            </summary>
        </member>
        <member name="M:Jcd.Tasks.BlockingTaskProcessor.Cancel">
            <summary>
            Signals the command processor to halt all processing immediately. This also cancels all tasks created
            by this task command processor. This is mostly intended to be called during application shutdown.
            </summary>
        </member>
        <member name="P:Jcd.Tasks.BlockingTaskProcessor.IsStarted">
            <summary>
            Gets a flag indicating if the command processing has started. (it might be paused though).
            </summary>
        </member>
        <member name="P:Jcd.Tasks.BlockingTaskProcessor.IsPaused">
            <summary>
            Gets a flag indicating if the command processing is currently paused.
            </summary>
        </member>
        <member name="M:Jcd.Tasks.BlockingTaskProcessor.Pause">
            <summary>
            Pauses the retrieval and execution of queued tasks. If a task is in the middle of being started when this is
            called it will still get started.
            </summary>
        </member>
        <member name="M:Jcd.Tasks.BlockingTaskProcessor.Resume">
            <summary>
            Resumes command processing.
            </summary>
        </member>
        <member name="M:Jcd.Tasks.BlockingTaskProcessor.PauseAsync">
            <summary>
            Pauses the retrieval and execution of queued tasks. If a task is in the middle of being started
            when this is called it will still get started.
            </summary>
        </member>
        <member name="M:Jcd.Tasks.BlockingTaskProcessor.ResumeAsync">
            <summary>
            Resumes command processing.
            </summary>
        </member>
        <member name="M:Jcd.Tasks.BlockingTaskProcessor.StartProcessing">
            <summary>
            Starts the processing of queued commands.
            </summary>
        </member>
        <member name="M:Jcd.Tasks.BlockingTaskProcessor.Dispose">
            <inheritdoc />
        </member>
        <member name="T:Jcd.Tasks.NamespaceDoc">
            <summary>
            Provides classes and extension methods to assist with the creation, execution, and
            management of <see cref="T:System.Threading.Tasks.Task"/> instances.
            </summary>
        </member>
        <member name="T:Jcd.Tasks.SynchronizedValue`1">
            <summary>
            Provides a simple async-safe method of setting, getting, and altering values intended to be shared among tasks and threads.
            </summary>
            <remarks>
            <para>
            While this provides a method of easily ensuring any one shared value is appropriately
            locked during setting or getting, you still need to thoroughly understand your
            use case. For example, having two <see cref="T:Jcd.Tasks.SynchronizedValue`1"/> instances accessed
            by two different threads, in rapid succession, in different orders can cause
            potentially unexpected results.
            </para>
            <para>
            In cases where the pair/tuple must be consistent at all times across all threads,
            consider creating a struct containing the necessary fields/properties and wrapping that
            in a SynchronizedValue instead of each individual field/property.
            </para>
            <para>
            As well this implementation uses <see cref="T:System.Threading.SemaphoreSlim"/> and requires Dispose to be called.
            Either implement <see cref="T:System.IDisposable"/> or call it directly at the appropriate time.
            </para>
            </remarks>
            <typeparam name="T">The data type to synchronize access to.</typeparam>
        </member>
        <member name="M:Jcd.Tasks.SynchronizedValue`1.#ctor(`0)">
            <summary>
            Constructs an <see cref="T:Jcd.Tasks.SynchronizedValue`1"/> instance.
            </summary>
            <param name="initialValue">The starting value.</param>
        </member>
        <member name="P:Jcd.Tasks.SynchronizedValue`1.Value">
            <summary>
            The synchronized value.
            </summary>
        </member>
        <member name="M:Jcd.Tasks.SynchronizedValue`1.GetValueAsync">
            <summary>
            Gets the value in an async friendly manner.
            </summary>
            <returns>A <see cref="T:System.Threading.Tasks.Task`1"/> containing the retrieved value.</returns>
        </member>
        <member name="M:Jcd.Tasks.SynchronizedValue`1.SetValueAsync(`0)">
            <summary>
            Sets the current value to the provided value.
            </summary>
            <param name="value">The provided value.</param>
            <returns>A <see cref="T:System.Threading.Tasks.Task`1"/> containing the provided value.</returns>
        </member>
        <member name="M:Jcd.Tasks.SynchronizedValue`1.GetValue">
            <summary>
            Retrieves the current value. If another thread edits the value, moment later a subsequent
            call will yield a different result. 
            </summary>
            <returns>The current value as of establishing the lock.</returns>
        </member>
        <member name="M:Jcd.Tasks.SynchronizedValue`1.SetValue(`0)">
            <summary>
            Sets the current value to the provided value.
            </summary>
            <param name="value">The provided value.</param>
            <returns>The provided value.</returns>
        </member>
        <member name="M:Jcd.Tasks.SynchronizedValue`1.ChangeValue(System.Func{`0,`0})">
            <summary>
            Calls the provided function, passing in the current value, and assigns the result of the
            function call, to the current value.
            </summary>
            <param name="func">The function to call.</param>
            <returns>The result of calling the function.</returns>
        </member>
        <member name="M:Jcd.Tasks.SynchronizedValue`1.ChangeValueAsync(System.Func{`0,`0})">
            <summary>
            Calls the provided function, passing in the current value, and assigns the result of the
            function call, to the current value.
            </summary>
            <param name="func">The function to call.</param>
            <returns>A <see cref="T:System.Threading.Tasks.Task`1"/> containing the result of calling the function.</returns>
        </member>
        <member name="M:Jcd.Tasks.SynchronizedValue`1.Dispose">
            <inheritdoc />
        </member>
        <member name="T:Jcd.Tasks.TaskExtensions">
            <summary>
            A set of helpers for <see cref="T:System.Threading.Tasks.Task"/> objects.
            </summary>
        </member>
        <member name="M:Jcd.Tasks.TaskExtensions.IsUnstarted(System.Threading.Tasks.Task)">
            <summary>
            Checks if a task is unstarted and startable. (Status==Created)
            </summary>
            <param name="task">the task to inspect</param>
            <returns>True if unstarted. False otherwise.</returns>
        </member>
        <member name="M:Jcd.Tasks.TaskExtensions.TryWaitAsync(System.Threading.Tasks.Task)">
            <summary>
            Tries to await a task regardless of status. 
            </summary>
            <param name="task">The task to try awaiting.</param>
            <returns>true if awaited without exception. false otherwise.</returns>
            <remarks>If successfully awaited, this method will block until the task completes.</remarks>
        </member>
        <member name="M:Jcd.Tasks.TaskExtensions.TryWait(System.Threading.Tasks.Task)">
            <summary>
            Tries to await a task regardless of status. 
            </summary>
            <param name="task">The task to try awaiting.</param>
            <returns>true if awaited without exception. false otherwise.</returns>
        </member>
        <member name="M:Jcd.Tasks.TaskExtensions.Run(System.Threading.Tasks.Task)">
            <summary>
            Calls <see cref="M:Jcd.Tasks.TaskExtensions.TryRun(System.Threading.Tasks.Task,System.Exception@)"/> on a task then returns the task, discarding exceptions.
            </summary>
            <param name="task">the task to start</param>
            <returns>the original task</returns>
        </member>
        <member name="M:Jcd.Tasks.TaskExtensions.Run``1(System.Threading.Tasks.Task{``0})">
            <summary>
            Calls <see cref="M:Jcd.Tasks.TaskExtensions.TryRun(System.Threading.Tasks.Task,System.Exception@)"/> on a task then returns the task, discarding exceptions.
            </summary>
            <param name="task">the task to start</param>
            <typeparam name="TResult">The type of data returned from the task.</typeparam>
            <returns>the original task</returns>
            <remarks>
            While this returns the original task, it doesn't guarantee it's awaitable. Only call
            this method if you've got 100% control over the lifecycle of the task. Otherwise call
            <see cref="M:Jcd.Tasks.TaskExtensions.TryRun(System.Threading.Tasks.Task,System.Exception@)"/> instead and inspect the results before calling await.
            </remarks>
        </member>
        <member name="M:Jcd.Tasks.TaskExtensions.TryRun(System.Threading.Tasks.Task,System.Exception@)">
            <summary>
            Tries to successfully call start. 
            </summary>
            <param name="task">The </param>
            <param name="exception"></param>
            <returns>
            <see cref="F:Jcd.Tasks.TryRunResult.SuccessfullyCalled"/> when the Start was called and no exception occurred.
            <see cref="F:Jcd.Tasks.TryRunResult.AlreadyStarted"/> When the task was already in a started state. Start was not called.
            <see cref="F:Jcd.Tasks.TryRunResult.ErrorDuringStart"/> When start was called and an exception occurred during the call to start. Check the exception parameter for details.
            </returns>
        </member>
        <member name="T:Jcd.Tasks.TryRunResult">
            <summary>
            The possible results of calling <see cref="M:Jcd.Tasks.TaskExtensions.TryRun(System.Threading.Tasks.Task,System.Exception@)"/>
            </summary>
        </member>
        <member name="F:Jcd.Tasks.TryRunResult.SuccessfullyCalled">
            <summary>
            Start was called and no exception resulted.
            </summary>
        </member>
        <member name="F:Jcd.Tasks.TryRunResult.AlreadyStarted">
            <summary>
            The task was already in a started state. Start was not called.
            </summary>
        </member>
        <member name="F:Jcd.Tasks.TryRunResult.ErrorDuringStart">
            <summary>
            An exception occurred during the call to start. 
            </summary>
        </member>
        <member name="T:Jcd.Tasks.UnstartedTask">
            <summary>
            A Task factory that wraps the constructor with a tiny bit of logic, simplifying the process
            of directly creating unstarted <see cref="T:System.Threading.Tasks.Task"/>s.
            </summary>
        </member>
        <member name="M:Jcd.Tasks.UnstartedTask.Create(System.Action,System.Nullable{System.Threading.CancellationToken},System.Threading.Tasks.TaskCreationOptions)">
            <summary>
            Creates an unstarted <see cref="T:System.Threading.Tasks.Task"/> as a proxy for an action. Once started the task will execute the action.
            </summary>
            <param name="action">The work to execute.</param>
            <param name="cancellationToken">The optional cancellation token for the task. The default is <see langword="null"/>.</param>
            <param name="options">Task <see cref="T:System.Threading.Tasks.TaskCreationOptions"/> for the task. The default is <see cref="F:System.Threading.Tasks.TaskCreationOptions.RunContinuationsAsynchronously"/></param>
            <returns>An unstarted <see cref="T:System.Threading.Tasks.Task"/> proxy for the action.</returns>
        </member>
        <member name="M:Jcd.Tasks.UnstartedTask.Create(System.Func{System.Threading.Tasks.Task},System.Nullable{System.Threading.CancellationToken},System.Threading.Tasks.TaskCreationOptions)">
            <summary>
            Creates an unstarted <see cref="T:System.Threading.Tasks.Task"/> as a proxy for an asynchronous action. Once started the task will execute the action. 
            </summary>
            <param name="action"></param>
            <param name="cancellationToken">The optional cancellation token for the task. The default is <see langword="null"/>.</param>
            <param name="options">Task <see cref="T:System.Threading.Tasks.TaskCreationOptions"/> for the task. The default is <see cref="F:System.Threading.Tasks.TaskCreationOptions.RunContinuationsAsynchronously"/></param>
            <returns>An unstarted <see cref="T:System.Threading.Tasks.Task"/> proxy for the asynchronous action.</returns>
        </member>
        <member name="M:Jcd.Tasks.UnstartedTask.Create``1(System.Func{``0},System.Nullable{System.Threading.CancellationToken},System.Threading.Tasks.TaskCreationOptions)">
            <summary>
            Creates an unstarted <see cref="T:System.Threading.Tasks.Task`1"/> as a proxy for a function. Once started the task will execute the function.
            </summary>
            <param name="function">The function to execute.</param>
            <param name="cancellationToken">The optional cancellation token for the task. The default is <see langword="null"/>.</param>
            <param name="options">Task <see cref="T:System.Threading.Tasks.TaskCreationOptions"/> for the task. The default is <see cref="F:System.Threading.Tasks.TaskCreationOptions.RunContinuationsAsynchronously"/></param>
            <returns>An unstarted <see cref="T:System.Threading.Tasks.Task`1"/> proxy for the function.</returns>
            <typeparam name="TResult">The type of the data returned.</typeparam>
        </member>
        <member name="M:Jcd.Tasks.UnstartedTask.Create``1(System.Func{System.Threading.Tasks.Task{``0}},System.Nullable{System.Threading.CancellationToken},System.Threading.Tasks.TaskCreationOptions)">
            <summary>
            Creates an unstarted <see cref="T:System.Threading.Tasks.Task`1"/> as a proxy for an asynchronous function. Once started the task will execute the function.
            </summary>
            <param name="function"></param>
            <param name="cancellationToken">The optional cancellation token for the task. The default is <see langword="null"/>.</param>
            <param name="options">Task <see cref="T:System.Threading.Tasks.TaskCreationOptions"/> for the task. The default is <see cref="F:System.Threading.Tasks.TaskCreationOptions.RunContinuationsAsynchronously"/></param>
            <returns>An unstarted <see cref="T:System.Threading.Tasks.Task`1"/> proxy for the asynchronous function.</returns>
            <typeparam name="TResult">The type of the data returned.</typeparam>
        </member>
    </members>
</doc>
