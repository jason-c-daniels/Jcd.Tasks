<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Jcd.Tasks</name>
    </assembly>
    <members>
        <member name="T:Jcd.Tasks.BlockingTaskProcessor">
            <summary>
            Represents a high level object that enqueues and executes actions, functions, and unstarted tasks,
            waiting for each to complete before executing the next.
            </summary>
            <remarks>
            <para>
            You must ensure all shared resources for the enqueued tasks have their access synchronized
            appropriately.
            </para>
            <para>
            <i>NOTE: This was really just a thought experiment. There are probably legitimately better ways of
            doing this built in to .Net. I had trouble finding them. If you find them, please let me know!</i>
            </para>
            </remarks>
        </member>
        <member name="P:Jcd.Tasks.BlockingTaskProcessor.QueueLength">
            <summary>
            The number of pending commands.
            </summary>
        </member>
        <member name="M:Jcd.Tasks.BlockingTaskProcessor.#ctor(System.Boolean)">
            <summary>
            Constructs a <see cref="T:Jcd.Tasks.BlockingTaskProcessor"/>
            </summary>
            <param name="autoStart"></param>
        </member>
        <member name="M:Jcd.Tasks.BlockingTaskProcessor.Enqueue(System.Action)">
            <summary>
            Enqueues an action. This is a "fire and forget" method. Control is immediately
            returned to the caller.
            </summary>
            <param name="command">The action to enqueue.</param>
        </member>
        <member name="M:Jcd.Tasks.BlockingTaskProcessor.Enqueue(System.Func{System.Threading.Tasks.Task})">
            <summary>
            Enqueues an async action. This is a "fire and forget" method.
            Control is returned to the caller immediately.
            </summary>
            <param name="command">The asynchronous action to enqueue.</param>
        </member>
        <member name="M:Jcd.Tasks.BlockingTaskProcessor.Enqueue``1(System.Func{``0})">
            <summary>
            Enqueues a function. This is a "fire and forget" method.
            The function result will not be available and control is immediately returned to the caller.
            </summary>
            <param name="command">The command to enqueue.</param>
        </member>
        <member name="M:Jcd.Tasks.BlockingTaskProcessor.Enqueue``1(System.Func{System.Threading.Tasks.Task{``0}})">
            <summary>
            Enqueues an async function. This is a "fire and forget" method.
            The function result will not be available and control is immediately returned to the caller.
            </summary>
            <param name="command">The async function to enqueue.</param>
        </member>
        <member name="M:Jcd.Tasks.BlockingTaskProcessor.EnqueueAndGetProxy(System.Action)">
            <summary>
            Enqueues an action and returns a proxy task that will execute the action.
            Awaiting the returned proxy <see cref="T:System.Threading.Tasks.Task"/> waits for the enqueued action to finish executing.
            </summary>
            <param name="command">The action to execute.</param>
            <returns>The <see cref="T:System.Threading.Tasks.Task"/> that will execute the enqueued action.</returns>
            <remarks>
            Awaiting this task before <see cref="M:Jcd.Tasks.BlockingTaskProcessor.StartProcessing"/> is called will cause the calling
            thread of execution to block until <see cref="M:Jcd.Tasks.BlockingTaskProcessor.StartProcessing"/> is called. Ensure that
            either <see cref="M:Jcd.Tasks.BlockingTaskProcessor.StartProcessing"/> has already been called, or that your program has
            a mechanism in another thread to call <see cref="M:Jcd.Tasks.BlockingTaskProcessor.StartProcessing"/>. You really need to
            call <see cref="M:Jcd.Tasks.BlockingTaskProcessor.StartProcessing"/> for awaiting the result to work.
            </remarks>
        </member>
        <member name="M:Jcd.Tasks.BlockingTaskProcessor.EnqueueAndGetProxy(System.Func{System.Threading.Tasks.Task})">
            <summary>
            Enqueues an async action and returns a proxy task that will execute the action.
            Awaiting the returned proxy <see cref="T:System.Threading.Tasks.Task"/> waits for the enqueued action to finish executing.
            </summary>
            <param name="command">The async action to enqueue.</param>
            <returns>The <see cref="T:System.Threading.Tasks.Task`1"/> that will execute the enqueued action.</returns>
            <remarks>
            Awaiting this task before <see cref="M:Jcd.Tasks.BlockingTaskProcessor.StartProcessing"/> is called will cause the calling
            thread of execution to block until <see cref="M:Jcd.Tasks.BlockingTaskProcessor.StartProcessing"/> is called. Ensure that
            either <see cref="M:Jcd.Tasks.BlockingTaskProcessor.StartProcessing"/> has already been called, or that your program has
            a mechanism in another thread to call <see cref="M:Jcd.Tasks.BlockingTaskProcessor.StartProcessing"/>. You really need to
            call <see cref="M:Jcd.Tasks.BlockingTaskProcessor.StartProcessing"/> for awaiting the result to work.
            </remarks>
        </member>
        <member name="M:Jcd.Tasks.BlockingTaskProcessor.EnqueueAndGetProxy``1(System.Func{``0})">
            <summary>
            Enqueues a function and returns a proxy task that will execute the function.
            Awaiting the returned <see cref="T:System.Threading.Tasks.Task"/> waits for the enqueued function to finish executing
            and returns the result.
            </summary>
            <param name="command">The command to execute.</param>
            <typeparam name="TResult">The data type returned by the function</typeparam>
            <returns>The <see cref="T:System.Threading.Tasks.Task`1"/> that will execute the enqueued action, once dequeued.</returns>
            <remarks>
            Awaiting this task before <see cref="M:Jcd.Tasks.BlockingTaskProcessor.StartProcessing"/> is called will cause the calling
            thread of execution to block until <see cref="M:Jcd.Tasks.BlockingTaskProcessor.StartProcessing"/> is called. Ensure that
            either <see cref="M:Jcd.Tasks.BlockingTaskProcessor.StartProcessing"/> has already been called, or that your program has
            a mechanism in another thread to call <see cref="M:Jcd.Tasks.BlockingTaskProcessor.StartProcessing"/>. You really need to
            call <see cref="M:Jcd.Tasks.BlockingTaskProcessor.StartProcessing"/> for awaiting the result to work.
            </remarks>
        </member>
        <member name="M:Jcd.Tasks.BlockingTaskProcessor.EnqueueAndGetProxy``1(System.Func{System.Threading.Tasks.Task{``0}})">
            <summary>
            Enqueues an async function and returns a proxy task that will execute the function.
            Awaiting the returned <see cref="T:System.Threading.Tasks.Task"/> waits for the enqueued function to finish executing
            and returns the result.
            </summary>
            <param name="command">The async function to enqueue.</param>
            <typeparam name="TResult">The data type returned by the function.</typeparam>
            <returns>The <see cref="T:System.Threading.Tasks.Task`1"/> that will execute the enqueued action.</returns>
            <remarks>
            Awaiting this task before <see cref="M:Jcd.Tasks.BlockingTaskProcessor.StartProcessing"/> is called will cause the calling
            thread of execution to block until <see cref="M:Jcd.Tasks.BlockingTaskProcessor.StartProcessing"/> is called. Ensure that
            either <see cref="M:Jcd.Tasks.BlockingTaskProcessor.StartProcessing"/> has already been called, or that your program has
            a mechanism in another thread to call <see cref="M:Jcd.Tasks.BlockingTaskProcessor.StartProcessing"/>. You really need to
            call <see cref="M:Jcd.Tasks.BlockingTaskProcessor.StartProcessing"/> for awaiting the result to work.
            </remarks>
        </member>
        <member name="M:Jcd.Tasks.BlockingTaskProcessor.TryEnqueueTask``1(System.Threading.Tasks.Task{``0},System.Boolean@)">
            <summary>
            Tries to enqueues a task for later execution. If the passed in task is not unstarted,
            it's not enqueued.
            </summary>
            <param name="task">the unstarted task</param>
            <param name="enqueued">a flag indicating if the task was actually enqueued</param>
            <typeparam name="TResult">The result type of the task.</typeparam>
            <returns>The passed in task.</returns>
            <exception cref="T:System.ArgumentNullException">When <paramref name="task"/> is <see langword="null"/> </exception>
            <remarks>
            <para>
            When passing in a previously started task the task is returned so that you can still await
            the result of the associated action. This is to support framework builders who may not control
            if a task is started or not.
            </para>
            <para>
            The reason for not enqueuing is to prevent such tasks, which can't be started, from
            occupying a position in the execution queue. This allows the processor to get to actual
            unstarted tasks sooner.
            </para>
            </remarks>
        </member>
        <member name="M:Jcd.Tasks.BlockingTaskProcessor.TryEnqueueTask(System.Threading.Tasks.Task,System.Boolean@)">
            <summary>
            Tries to enqueues a task for later execution. If the passed in task is already
            started, it's not enqueued.
            </summary>
            <param name="task">the unstarted task</param>
            <param name="enqueued">a flag indicating if the task was actually enqueued.</param>
            <returns>The passed in task.</returns>
            <exception cref="T:System.ArgumentNullException">When <paramref name="task"/> is <see langword="null"/> </exception>
            <remarks>
            <para>
            When passing in a previously started task the task is still returned so that you can still await the result
            of the associated action. This is to support framework builders who may not control
            if a task is unstarted or not.
            </para>
            <para>
            The reason for not enqueuing is to prevent such tasks, which can't be started, from
            occupying a position in the execution queue. This allows the processor to get to actual
            unstarted tasks sooner.
            </para>
            </remarks>
        </member>
        <member name="P:Jcd.Tasks.BlockingTaskProcessor.HasTasks">
            <summary>
            Gets a flag indicating if there are any pending tasks.
            </summary>
        </member>
        <member name="M:Jcd.Tasks.BlockingTaskProcessor.StopProcessingAndClearQueue">
            <summary>
            Signals the task processor to halt all processing immediately. This also cancels all
            tasks created by this task task processor. This is mostly intended to be called
            during application shutdown.
            </summary>
        </member>
        <member name="P:Jcd.Tasks.BlockingTaskProcessor.IsStarted">
            <summary>
            Gets a flag indicating if the task processing has started. (it might be paused though).
            </summary>
        </member>
        <member name="P:Jcd.Tasks.BlockingTaskProcessor.IsPaused">
            <summary>
            Gets a flag indicating if the command processing is currently paused.
            </summary>
        </member>
        <member name="M:Jcd.Tasks.BlockingTaskProcessor.Pause">
            <summary>
            Pauses the retrieval and execution of queued tasks. If a task is in the middle of being started when this is
            called it will still get started.
            </summary>
        </member>
        <member name="M:Jcd.Tasks.BlockingTaskProcessor.Resume">
            <summary>
            Resumes command processing.
            </summary>
        </member>
        <member name="M:Jcd.Tasks.BlockingTaskProcessor.PauseAsync">
            <summary>
            Pauses the retrieval and execution of queued tasks. If a task is in the middle of being started
            when this is called it will still get started.
            </summary>
        </member>
        <member name="M:Jcd.Tasks.BlockingTaskProcessor.ResumeAsync">
            <summary>
            Resumes task processing.
            </summary>
        </member>
        <member name="M:Jcd.Tasks.BlockingTaskProcessor.StartProcessing">
            <summary>
            Starts the processing of queued tasks.
            </summary>
        </member>
        <member name="M:Jcd.Tasks.BlockingTaskProcessor.Dispose">
            <inheritdoc />
        </member>
        <member name="T:Jcd.Tasks.CurrentSchedulerTaskRunner">
            <summary>
            A TaskRunner that schedules tasks on the current TaskScheduler or a user provided TaskScheduler.
            </summary>
        </member>
        <member name="M:Jcd.Tasks.CurrentSchedulerTaskRunner.Run(System.Action,System.Threading.Tasks.TaskScheduler)">
            <summary>
            
            </summary>
            <param name="action"></param>
            <param name="scheduler"></param>
            <returns></returns>
        </member>
        <member name="M:Jcd.Tasks.CurrentThreadTaskScheduler.QueueTask(System.Threading.Tasks.Task)">
            <summary>Runs the provided Task synchronously on the current thread.</summary>
            <param name="task">The task to be executed.</param>
        </member>
        <member name="M:Jcd.Tasks.CurrentThreadTaskScheduler.TryExecuteTaskInline(System.Threading.Tasks.Task,System.Boolean)">
            <summary>Runs the provided Task synchronously on the current thread.</summary>
            <param name="task">The task to be executed.</param>
            <param name="taskWasPreviouslyQueued">Whether the Task was previously queued to the scheduler.</param>
            <returns>True if the Task was successfully executed; otherwise, false.</returns>
        </member>
        <member name="M:Jcd.Tasks.CurrentThreadTaskScheduler.GetScheduledTasks">
            <summary>Gets the Tasks currently scheduled to this scheduler.</summary>
            <returns>An empty enumerable, as Tasks are never queued, only executed.</returns>
        </member>
        <member name="P:Jcd.Tasks.CurrentThreadTaskScheduler.MaximumConcurrencyLevel">
            <summary>Gets the maximum degree of parallelism for this scheduler.</summary>
        </member>
        <member name="T:Jcd.Tasks.QueuedTaskScheduler">
            <summary>
            Provides a TaskScheduler that provides control over priorities, fairness, and the underlying threads utilized.
            </summary>
        </member>
        <member name="T:Jcd.Tasks.QueuedTaskScheduler.QueuedTaskSchedulerDebugView">
            <summary>Debug view for the QueuedTaskScheduler.</summary>
        </member>
        <member name="F:Jcd.Tasks.QueuedTaskScheduler.QueuedTaskSchedulerDebugView._scheduler">
            <summary>The scheduler.</summary>
        </member>
        <member name="M:Jcd.Tasks.QueuedTaskScheduler.QueuedTaskSchedulerDebugView.#ctor(Jcd.Tasks.QueuedTaskScheduler)">
            <summary>Initializes the debug view.</summary>
            <param name="scheduler">The scheduler.</param>
        </member>
        <member name="P:Jcd.Tasks.QueuedTaskScheduler.QueuedTaskSchedulerDebugView.ScheduledTasks">
            <summary>Gets all of the Tasks queued to the scheduler directly.</summary>
        </member>
        <member name="P:Jcd.Tasks.QueuedTaskScheduler.QueuedTaskSchedulerDebugView.Queues">
            <summary>Gets the prioritized and fair queues.</summary>
        </member>
        <member name="F:Jcd.Tasks.QueuedTaskScheduler._queueGroups">
            <summary>
            A sorted list of round-robin queue lists.  Tasks with the smallest priority value
            are preferred.  Priority groups are round-robin'd through in order of priority.
            </summary>
        </member>
        <member name="F:Jcd.Tasks.QueuedTaskScheduler._disposeCancellation">
            <summary>Cancellation token used for disposal.</summary>
        </member>
        <member name="F:Jcd.Tasks.QueuedTaskScheduler._concurrencyLevel">
            <summary>
            The maximum allowed concurrency level of this scheduler.  If custom threads are
            used, this represents the number of created threads.
            </summary>
        </member>
        <member name="F:Jcd.Tasks.QueuedTaskScheduler._taskProcessingThread">
            <summary>Whether we're processing tasks on the current thread.</summary>
        </member>
        <member name="F:Jcd.Tasks.QueuedTaskScheduler._targetScheduler">
            <summary>The scheduler onto which actual work is scheduled.</summary>
        </member>
        <member name="F:Jcd.Tasks.QueuedTaskScheduler._nonthreadsafeTaskQueue">
            <summary>The queue of tasks to process when using an underlying target scheduler.</summary>
        </member>
        <member name="F:Jcd.Tasks.QueuedTaskScheduler._delegatesQueuedOrRunning">
            <summary>The number of Tasks that have been queued or that are running whiel using an underlying scheduler.</summary>
        </member>
        <member name="F:Jcd.Tasks.QueuedTaskScheduler._threads">
            <summary>The threads used by the scheduler to process work.</summary>
        </member>
        <member name="F:Jcd.Tasks.QueuedTaskScheduler._blockingTaskQueue">
            <summary>The collection of tasks to be executed on our custom threads.</summary>
        </member>
        <member name="M:Jcd.Tasks.QueuedTaskScheduler.#ctor">
            <summary>Initializes the scheduler.</summary>
        </member>
        <member name="M:Jcd.Tasks.QueuedTaskScheduler.#ctor(System.Threading.Tasks.TaskScheduler)">
            <summary>Initializes the scheduler.</summary>
            <param name="targetScheduler">The target underlying scheduler onto which this sceduler's work is queued.</param>
        </member>
        <member name="M:Jcd.Tasks.QueuedTaskScheduler.#ctor(System.Threading.Tasks.TaskScheduler,System.Int32)">
            <summary>Initializes the scheduler.</summary>
            <param name="targetScheduler">The target underlying scheduler onto which this sceduler's work is queued.</param>
            <param name="maxConcurrencyLevel">The maximum degree of concurrency allowed for this scheduler's work.</param>
        </member>
        <member name="M:Jcd.Tasks.QueuedTaskScheduler.#ctor(System.Int32)">
            <summary>Initializes the scheduler.</summary>
            <param name="threadCount">The number of threads to create and use for processing work items.</param>
        </member>
        <member name="M:Jcd.Tasks.QueuedTaskScheduler.#ctor(System.Int32,System.String,System.Boolean,System.Threading.ThreadPriority,System.Threading.ApartmentState,System.Int32,System.Action,System.Action)">
            <summary>Initializes the scheduler.</summary>
            <param name="threadCount">The number of threads to create and use for processing work items.</param>
            <param name="threadName">The name to use for each of the created threads.</param>
            <param name="useForegroundThreads">A Boolean value that indicates whether to use foreground threads instead of background.</param>
            <param name="threadPriority">The priority to assign to each thread.</param>
            <param name="threadApartmentState">The apartment state to use for each thread.</param>
            <param name="threadMaxStackSize">The stack size to use for each thread.</param>
            <param name="threadInit">An initialization routine to run on each thread.</param>
            <param name="threadFinally">A finalization routine to run on each thread.</param>
        </member>
        <member name="M:Jcd.Tasks.QueuedTaskScheduler.ThreadBasedDispatchLoop(System.Action,System.Action)">
            <summary>The dispatch loop run by all threads in this scheduler.</summary>
            <param name="threadInit">An initialization routine to run when the thread begins.</param>
            <param name="threadFinally">A finalization routine to run before the thread ends.</param>
        </member>
        <member name="P:Jcd.Tasks.QueuedTaskScheduler.DebugQueueCount">
            <summary>Gets the number of queues currently activated.</summary>
        </member>
        <member name="P:Jcd.Tasks.QueuedTaskScheduler.DebugTaskCount">
            <summary>Gets the number of tasks currently scheduled.</summary>
        </member>
        <member name="M:Jcd.Tasks.QueuedTaskScheduler.FindNextTask_NeedsLock(System.Threading.Tasks.Task@,Jcd.Tasks.QueuedTaskScheduler.QueuedTaskSchedulerQueue@)">
            <summary>Find the next task that should be executed, based on priorities and fairness and the like.</summary>
            <param name="targetTask">The found task, or null if none was found.</param>
            <param name="queueForTargetTask">
            The scheduler associated with the found task.  Due to security checks inside of TPL,  
            this scheduler needs to be used to execute that task.
            </param>
        </member>
        <member name="M:Jcd.Tasks.QueuedTaskScheduler.QueueTask(System.Threading.Tasks.Task)">
            <summary>Queues a task to the scheduler.</summary>
            <param name="task">The task to be queued.</param>
        </member>
        <member name="M:Jcd.Tasks.QueuedTaskScheduler.ProcessPrioritizedAndBatchedTasks">
            <summary>
            Process tasks one at a time in the best order.  
            This should be run in a Task generated by QueueTask.
            It's been separated out into its own method to show up better in Parallel Tasks.
            </summary>
        </member>
        <member name="M:Jcd.Tasks.QueuedTaskScheduler.NotifyNewWorkItem">
            <summary>Notifies the pool that there's a new item to be executed in one of the round-robin queues.</summary>
        </member>
        <member name="M:Jcd.Tasks.QueuedTaskScheduler.TryExecuteTaskInline(System.Threading.Tasks.Task,System.Boolean)">
            <summary>Tries to execute a task synchronously on the current thread.</summary>
            <param name="task">The task to execute.</param>
            <param name="taskWasPreviouslyQueued">Whether the task was previously queued.</param>
            <returns>true if the task was executed; otherwise, false.</returns>
        </member>
        <member name="M:Jcd.Tasks.QueuedTaskScheduler.GetScheduledTasks">
            <summary>Gets the tasks scheduled to this scheduler.</summary>
            <returns>An enumerable of all tasks queued to this scheduler.</returns>
            <remarks>This does not include the tasks on sub-schedulers.  Those will be retrieved by the debugger separately.</remarks>
        </member>
        <member name="P:Jcd.Tasks.QueuedTaskScheduler.MaximumConcurrencyLevel">
            <summary>Gets the maximum concurrency level to use when processing tasks.</summary>
        </member>
        <member name="M:Jcd.Tasks.QueuedTaskScheduler.Dispose">
            <summary>Initiates shutdown of the scheduler.</summary>
        </member>
        <member name="M:Jcd.Tasks.QueuedTaskScheduler.ActivateNewQueue">
            <summary>Creates and activates a new scheduling queue for this scheduler.</summary>
            <returns>The newly created and activated queue at priority 0.</returns>
        </member>
        <member name="M:Jcd.Tasks.QueuedTaskScheduler.ActivateNewQueue(System.Int32)">
            <summary>Creates and activates a new scheduling queue for this scheduler.</summary>
            <param name="priority">The priority level for the new queue.</param>
            <returns>The newly created and activated queue at the specified priority.</returns>
        </member>
        <member name="M:Jcd.Tasks.QueuedTaskScheduler.RemoveQueue_NeedsLock(Jcd.Tasks.QueuedTaskScheduler.QueuedTaskSchedulerQueue)">
            <summary>Removes a scheduler from the group.</summary>
            <param name="queue">The scheduler to be removed.</param>
        </member>
        <member name="T:Jcd.Tasks.QueuedTaskScheduler.QueueGroup">
            <summary>A group of queues a the same priority level.</summary>
        </member>
        <member name="F:Jcd.Tasks.QueuedTaskScheduler.QueueGroup.NextQueueIndex">
            <summary>The starting index for the next round-robin traversal.</summary>
        </member>
        <member name="M:Jcd.Tasks.QueuedTaskScheduler.QueueGroup.CreateSearchOrder">
            <summary>Creates a search order through this group.</summary>
            <returns>An enumerable of indices for this group.</returns>
        </member>
        <member name="T:Jcd.Tasks.QueuedTaskScheduler.QueuedTaskSchedulerQueue">
            <summary>Provides a scheduling queue associatd with a QueuedTaskScheduler.</summary>
        </member>
        <member name="T:Jcd.Tasks.QueuedTaskScheduler.QueuedTaskSchedulerQueue.QueuedTaskSchedulerQueueDebugView">
            <summary>A debug view for the queue.</summary>
        </member>
        <member name="F:Jcd.Tasks.QueuedTaskScheduler.QueuedTaskSchedulerQueue.QueuedTaskSchedulerQueueDebugView._queue">
            <summary>The queue.</summary>
        </member>
        <member name="M:Jcd.Tasks.QueuedTaskScheduler.QueuedTaskSchedulerQueue.QueuedTaskSchedulerQueueDebugView.#ctor(Jcd.Tasks.QueuedTaskScheduler.QueuedTaskSchedulerQueue)">
            <summary>Initializes the debug view.</summary>
            <param name="queue">The queue to be debugged.</param>
        </member>
        <member name="P:Jcd.Tasks.QueuedTaskScheduler.QueuedTaskSchedulerQueue.QueuedTaskSchedulerQueueDebugView.Priority">
            <summary>Gets the priority of this queue in its associated scheduler.</summary>
        </member>
        <member name="P:Jcd.Tasks.QueuedTaskScheduler.QueuedTaskSchedulerQueue.QueuedTaskSchedulerQueueDebugView.Id">
            <summary>Gets the ID of this scheduler.</summary>
        </member>
        <member name="P:Jcd.Tasks.QueuedTaskScheduler.QueuedTaskSchedulerQueue.QueuedTaskSchedulerQueueDebugView.ScheduledTasks">
            <summary>Gets all of the tasks scheduled to this queue.</summary>
        </member>
        <member name="P:Jcd.Tasks.QueuedTaskScheduler.QueuedTaskSchedulerQueue.QueuedTaskSchedulerQueueDebugView.AssociatedScheduler">
            <summary>Gets the QueuedTaskScheduler with which this queue is associated.</summary>
        </member>
        <member name="F:Jcd.Tasks.QueuedTaskScheduler.QueuedTaskSchedulerQueue._pool">
            <summary>The scheduler with which this pool is associated.</summary>
        </member>
        <member name="F:Jcd.Tasks.QueuedTaskScheduler.QueuedTaskSchedulerQueue._workItems">
            <summary>The work items stored in this queue.</summary>
        </member>
        <member name="F:Jcd.Tasks.QueuedTaskScheduler.QueuedTaskSchedulerQueue._disposed">
            <summary>Whether this queue has been disposed.</summary>
        </member>
        <member name="F:Jcd.Tasks.QueuedTaskScheduler.QueuedTaskSchedulerQueue._priority">
            <summary>Gets the priority for this queue.</summary>
        </member>
        <member name="M:Jcd.Tasks.QueuedTaskScheduler.QueuedTaskSchedulerQueue.#ctor(System.Int32,Jcd.Tasks.QueuedTaskScheduler)">
            <summary>Initializes the queue.</summary>
            <param name="priority">The priority associated with this queue.</param>
            <param name="pool">The scheduler with which this queue is associated.</param>
        </member>
        <member name="P:Jcd.Tasks.QueuedTaskScheduler.QueuedTaskSchedulerQueue.WaitingTasks">
            <summary>Gets the number of tasks waiting in this scheduler.</summary>
        </member>
        <member name="M:Jcd.Tasks.QueuedTaskScheduler.QueuedTaskSchedulerQueue.GetScheduledTasks">
            <summary>Gets the tasks scheduled to this scheduler.</summary>
            <returns>An enumerable of all tasks queued to this scheduler.</returns>
        </member>
        <member name="M:Jcd.Tasks.QueuedTaskScheduler.QueuedTaskSchedulerQueue.QueueTask(System.Threading.Tasks.Task)">
            <summary>Queues a task to the scheduler.</summary>
            <param name="task">The task to be queued.</param>
        </member>
        <member name="M:Jcd.Tasks.QueuedTaskScheduler.QueuedTaskSchedulerQueue.TryExecuteTaskInline(System.Threading.Tasks.Task,System.Boolean)">
            <summary>Tries to execute a task synchronously on the current thread.</summary>
            <param name="task">The task to execute.</param>
            <param name="taskWasPreviouslyQueued">Whether the task was previously queued.</param>
            <returns>true if the task was executed; otherwise, false.</returns>
        </member>
        <member name="M:Jcd.Tasks.QueuedTaskScheduler.QueuedTaskSchedulerQueue.ExecuteTask(System.Threading.Tasks.Task)">
            <summary>Runs the specified ask.</summary>
            <param name="task">The task to execute.</param>
        </member>
        <member name="P:Jcd.Tasks.QueuedTaskScheduler.QueuedTaskSchedulerQueue.MaximumConcurrencyLevel">
            <summary>Gets the maximum concurrency level to use when processing tasks.</summary>
        </member>
        <member name="M:Jcd.Tasks.QueuedTaskScheduler.QueuedTaskSchedulerQueue.Dispose">
            <summary>Signals that the queue should be removed from the scheduler as soon as the queue is empty.</summary>
        </member>
        <member name="T:Jcd.Tasks.DualSTAThreadScheduler">
            <summary>
            Provides two STA threads
            </summary>
        </member>
        <member name="T:Jcd.Tasks.NamespaceDoc">
            <summary>
            Provides types and extension methods to assist with the creation, execution, and
            management of unstarted <see cref="T:System.Threading.Tasks.Task"/> instances.
            </summary>
        </member>
        <member name="T:Jcd.Tasks.SchedulerBoundTaskRunner`1">
            <summary>
            A TaskScheduler bound task runner. It ensures all tasks it creates are registered with either its own,
            or a user provided TaskScheduler.
            </summary>
        </member>
        <member name="M:Jcd.Tasks.SchedulerBoundTaskRunner`1.Run(System.Action,System.Threading.Tasks.TaskScheduler)">
            <summary>
            
            </summary>
            <param name="action"></param>
            <param name="scheduler"></param>
            <returns></returns>
        </member>
        <member name="T:Jcd.Tasks.SynchronizedValue`1">
            <summary>
            Provides a simple async-safe method of setting, getting, and altering values intended
            to be shared among tasks and threads.
            </summary>
            <typeparam name="T">The data type to synchronize access to.</typeparam>
            <remarks>
            <para>
            While this provides a method of easily ensuring any one shared value is appropriately
            locked during setting or getting, you still need to thoroughly understand your
            use case. For example, having two <see cref="T:Jcd.Tasks.SynchronizedValue`1"/> instances accessed
            by two different threads, in rapid succession, in different orders can cause
            potentially unexpected results.
            </para>
            <para>
            In cases where the pair/tuple must be consistent at all times across all accesses,
            consider creating a struct containing the necessary fields/properties and wrapping
            that in a <see cref="T:Jcd.Tasks.SynchronizedValue`1"/> instead of each individual field/property.
            </para>
            <para>
            As well this implementation uses <see cref="T:System.Threading.SemaphoreSlim"/> and requires Dispose to be
            called. Either implement <see cref="T:System.IDisposable"/> or call it directly at the appropriate
            time. See the documentation for <see cref="M:Jcd.Tasks.SynchronizedValue`1.ChangeValue(System.Func{`0,`0})"/> and <see cref="M:Jcd.Tasks.SynchronizedValue`1.ChangeValueAsync(System.Func{`0,System.Threading.Tasks.Task{`0}})"/>
            for recursive reentrancy considerations. <i>(don't try it)</i>
            </para>
            </remarks>
        </member>
        <member name="M:Jcd.Tasks.SynchronizedValue`1.#ctor(`0)">
            <summary>
            Constructs an <see cref="!:SimpleInterlockedValue&lt;T&gt;"/> instance.
            </summary>
            <param name="initialValue">The starting value.</param>
        </member>
        <member name="M:Jcd.Tasks.SynchronizedValue`1.Dispose">
            <inheritdoc />
        </member>
        <member name="P:Jcd.Tasks.SynchronizedValue`1.Value">
            <summary>
            Get the synchronized value.
            </summary>
            <example>
            <code>
            var sv = new SimpleInterlockedValue&lt;int&gt;(15);
            
            // get the value
            setValue = sv.Value;
            
            </code>
            </example>
        </member>
        <member name="M:Jcd.Tasks.SynchronizedValue`1.GetValueAsync">
            <summary>
            Gets the value in an async friendly manner.
            </summary>
            <returns>A <see cref="T:System.Threading.Tasks.Task`1"/> containing the retrieved value.</returns>
            <example>
            <code>
            var sv = new SimpleInterlockedValue&lt;int&gt;(15);
            
            // get the value
            await setValue = sv.GetValueAsync(20);
            
            </code>
            </example>
        </member>
        <member name="M:Jcd.Tasks.SynchronizedValue`1.SetValueAsync(`0)">
            <summary>
            Sets the current value to the provided value.
            </summary>
            <param name="value">The provided value.</param>
            <returns>A <see cref="T:System.Threading.Tasks.Task`1"/> containing the provided value.</returns>
            <example>
            <code>
            var sv = new SimpleInterlockedValue&lt;int&gt;();
            
            // set the value to 10.
            await setValue = sv.SetValueAsync(10);
            
            // set the value to 20.
            await setValue = sv.SetValueAsync(20);
            
            </code>
            </example>
        </member>
        <member name="M:Jcd.Tasks.SynchronizedValue`1.GetValue">
            <summary>
            Retrieves the current value. If another thread edits the value, moment later a subsequent
            call will yield a different result. 
            </summary>
            <returns>The current value as of establishing the lock.</returns>
            <example>
            <code>
            var sv = new SimpleInterlockedValue&lt;int&gt;(15);
            
            // get the value
            setValue = sv.GetValue(20);
            
            </code>
            </example>
        </member>
        <member name="M:Jcd.Tasks.SynchronizedValue`1.SetValue(`0)">
            <summary>
            Sets the current value to the provided value.
            </summary>
            <param name="value">The provided value.</param>
            <returns>The provided value.</returns>
            <example>
            <code>
            var sv = new SimpleInterlockedValue&lt;int&gt;();
            
            // set the value to 10.
            setValue = sv.SetValue(10);
            
            // set the value to 20.
            setValue = sv.SetValue(20);
            
            </code>
            </example>
        </member>
        <member name="M:Jcd.Tasks.SynchronizedValue`1.ChangeValue(System.Func{`0,`0})">
             <summary>
             Calls the provided function, passing in the current value, and assigns the result
             of the function call, to the current value. <b>This is not recursively reentrant.
             see remarks for details.</b>
             </summary>
             <param name="func">
             A function to call which receives the current value, modifies it, and returns the
             modified result.
             </param>
             <returns>The modified value.</returns>
             <example>
             Standard usage: pass in a function to manipulate the current value.
             <code>
             var sv = new SimpleInterlockedValue&lt;int&gt;();
             
             // increment the value by one.
             var changedValue = sv.Do(x => x + 1);
             
             // increment the value by two.
             changedValue = sv.Do(x => x + 2);
             
             </code>
             </example>
             <remarks>
             <para>
             <b>WARNING:</b>This is <b>not</b> a recursively reentrant method. Never write code like
             the following.
             </para>
             <code>
             var sv=new SimpleInterlockedValue&lt;int&gt;(10);
            
             // deadlock yourself in a single line of code!
             var changedValue = sv.Do(x=>sv.Value+10);
             </code>
             </remarks>
        </member>
        <member name="M:Jcd.Tasks.SynchronizedValue`1.ChangeValueAsync(System.Func{`0,System.Threading.Tasks.Task{`0}})">
             <summary>
             Calls the provided function, passing in the current value, and assigns the result
             of the function call, to the current value. <b>This is not recursively reentrant.
             see remarks for details.</b>
             </summary>
             <param name="func">The function to call.</param>
             <returns>A <see cref="T:System.Threading.Tasks.Task`1"/> containing the modified value.</returns>
             <example>
             Standard usage: pass in a function to manipulate the current value.
             <code>
             var sv = new SimpleInterlockedValue&lt;int&gt;();
             
             // increment the value by one.
             var changedValue = await sv.DoAsync(x => x + 1);
             
             // increment the value by two.
             changedValue = await sv.DoAsync(x => x + 2);
             
             // Perform some operation that requires the value to remain unchanged during the operation.
             var sameValue = await sv.DoAsync(x => { DoSomething(x); return x;});
             </code>
             </example>
             <remarks>
             <para>
             <b>WARNING:</b>This is <b>not</b> a recursively reentrant method. Never write code like
             the following.
             </para>
             <code>
             var sv=new SimpleInterlockedValue&lt;int&gt;(10);
            
             // deadlock yourself in a single line of code!
             var changedValue = await sv.ChangeValueAsync(x=>sv.Value+10);
             </code>
             </remarks>
        </member>
        <member name="T:Jcd.Tasks.TaskExtensions">
            <summary>
            A set of helpers for <see cref="T:System.Threading.Tasks.Task"/> objects.
            </summary>
        </member>
        <member name="M:Jcd.Tasks.TaskExtensions.IsUnstarted(System.Threading.Tasks.Task)">
            <summary>
            Checks if a task is unstarted and startable. (Status==Created)
            </summary>
            <param name="task">the task to inspect</param>
            <returns>True if unstarted. False otherwise.</returns>
        </member>
        <member name="M:Jcd.Tasks.TaskExtensions.Run(System.Threading.Tasks.Task)">
            <summary>
            Calls <see cref="M:Jcd.Tasks.TaskExtensions.TryStart(System.Threading.Tasks.Task,System.Exception@,System.Threading.Tasks.TaskScheduler)"/> on a task then returns the task, discarding exceptions.
            </summary>
            <param name="task">the task to start</param>
            <returns>the original task</returns>
            <remarks>
            While this returns the original task, it doesn't guarantee it's awaitable. Only call
            this method if you've got 100% control over the lifecycle of the task. Otherwise call
            <see cref="M:Jcd.Tasks.TaskExtensions.TryStart(System.Threading.Tasks.Task,System.Exception@,System.Threading.Tasks.TaskScheduler)"/> instead and inspect the results before calling await.
            </remarks>
        </member>
        <member name="M:Jcd.Tasks.TaskExtensions.Run``1(System.Threading.Tasks.Task{``0},System.Threading.Tasks.TaskScheduler)">
            <summary>
            Calls <see cref="M:Jcd.Tasks.TaskExtensions.TryStart(System.Threading.Tasks.Task,System.Exception@,System.Threading.Tasks.TaskScheduler)"/> on a task then returns the task, discarding exceptions.
            </summary>
            <param name="task">the task to start</param>
            <param name="taskScheduler">
            The <see cref="T:System.Threading.Tasks.TaskScheduler"/> to use for executing the task. If not provided the
            current <see cref="T:System.Threading.Tasks.TaskScheduler"/> is used.
            </param>
            <typeparam name="TResult">The type of data returned from the task.</typeparam>
            <returns>the original task</returns>
            <remarks>
            While this returns the original task, it doesn't guarantee it's awaitable. Only call
            this method if you've got 100% control over the lifecycle of the task. Otherwise call
            <see cref="M:Jcd.Tasks.TaskExtensions.TryStart(System.Threading.Tasks.Task,System.Exception@,System.Threading.Tasks.TaskScheduler)"/> instead and inspect the results before calling await.
            </remarks>
        </member>
        <member name="M:Jcd.Tasks.TaskExtensions.TryStart(System.Threading.Tasks.Task,System.Exception@,System.Threading.Tasks.TaskScheduler)">
            <summary>
            Tries to successfully call start. 
            </summary>
            <param name="task">The task to call Start on.</param>
            <param name="taskScheduler">
            The <see cref="T:System.Threading.Tasks.TaskScheduler"/> to use for executing the task. If not provided the
            current <see cref="T:System.Threading.Tasks.TaskScheduler"/> is used.
            </param>
            <param name="exception">The exception resulting from calling Start.</param>
            <returns>
            <see cref="F:Jcd.Tasks.TryStartResult.SuccessfullyStarted"/> when the Start was called and no exception occurred.
            <see cref="F:Jcd.Tasks.TryStartResult.AlreadyStarted"/> When the task was already in a started state. Start was not called.
            <see cref="F:Jcd.Tasks.TryStartResult.ErrorDuringStart"/> When start was called and an exception occurred during the call to start. Check the exception parameter for details.
            </returns>
        </member>
        <member name="M:Jcd.Tasks.TaskExtensions.TryWait(System.Threading.Tasks.Task,System.Threading.CancellationToken)">
            <summary>
            Waits on a running task until it completes, is cancelled, faults or times out.
            </summary>
            <param name="task">the task to wait on.</param>
            <param name="cancellationToken">An optional cancellation token.</param>
            <returns><see langword="true"/> if it ran to completion. <see langword="false"/> otherwise.</returns>
            <exception cref="T:System.InvalidOperationException">Thrown if the task is unstarted.</exception>
        </member>
        <member name="M:Jcd.Tasks.TaskExtensions.TryWait(System.Threading.Tasks.Task,System.TimeSpan,System.Nullable{System.Threading.CancellationToken})">
            <summary>
            Waits on a running task until it completes, is cancelled, faults or times out.
            </summary>
            <param name="task">the task to wait on.</param>
            <param name="timeout">the amount of time to wait. Must be a value between -1 (infinite) and  <see cref="F:System.Int32.MaxValue"/></param>
            <param name="cancellationToken">An optional cancellation token.</param>
            <returns><see langword="true"/> if ran to completion. <see langword="false"/> otherwise.</returns>
            <exception cref="T:System.InvalidOperationException">Thrown if the task is unstarted.</exception>
        </member>
        <member name="M:Jcd.Tasks.TaskExtensions.TryWait(System.Threading.Tasks.Task,System.Nullable{System.Int32},System.Nullable{System.Threading.CancellationToken})">
            <summary>
            Waits on a running task until it completes, is cancelled, faults or times out.
            This extension method swallows exceptions. The exception should be available on
            the Task.Exception property
            </summary>
            <param name="task">the task to wait on.</param>
            <param name="millisecondsTimeout">the amount of time to wait. Must be a value between -1 (infinite) and  <see cref="F:System.Int32.MaxValue"/></param>
            <param name="cancellationToken">An optional cancellation token.</param>
            <returns><see langword="true"/> if ran to completion. <see langword="false"/> otherwise.</returns>
        </member>
        <member name="M:Jcd.Tasks.ThreadScheduler.TryExecuteTaskInline(System.Threading.Tasks.Task,System.Boolean)">
            <summary>
            This the default implementation for this scheduler guarantees only its threads are processing tasks, so we cannot
            inline operations as inlining executes the task on the ThreadPool, which may not meet the same requirements as our
            dedicated threads.
            </summary>
            <param name="task">the task to try inlining</param>
            <param name="taskWasPreviouslyQueued">indicates if it was previously queued with this scheduler</param>
            <returns>true if it was executed inline.</returns>
        </member>
        <member name="T:Jcd.Tasks.TryStartResult">
            <summary>
            The possible results of calling <see cref="M:Jcd.Tasks.TaskExtensions.TryStart(System.Threading.Tasks.Task,System.Exception@,System.Threading.Tasks.TaskScheduler)"/>
            </summary>
        </member>
        <member name="F:Jcd.Tasks.TryStartResult.SuccessfullyStarted">
            <summary>
            Start was called and no exception resulted.
            </summary>
        </member>
        <member name="F:Jcd.Tasks.TryStartResult.AlreadyStarted">
            <summary>
            The task was already in a started state. Start was not called.
            </summary>
        </member>
        <member name="F:Jcd.Tasks.TryStartResult.ErrorDuringStart">
            <summary>
            An exception occurred during the call to start. 
            </summary>
        </member>
        <member name="T:Jcd.Tasks.UnstartedTask">
            <summary>
            A Task factory that wraps the constructor with a tiny bit of logic, simplifying the process
            of directly creating unstarted <see cref="T:System.Threading.Tasks.Task"/>s.
            </summary>
        </member>
        <member name="M:Jcd.Tasks.UnstartedTask.Create(System.Action,System.Nullable{System.Threading.CancellationToken},System.Threading.Tasks.TaskCreationOptions)">
            <summary>
            Creates an unstarted <see cref="T:System.Threading.Tasks.Task"/> as a proxy for an action. Once started the task will execute the action.
            </summary>
            <param name="action">The work to execute.</param>
            <param name="cancellationToken">The optional cancellation token for the task. The default is <see langword="null"/>.</param>
            <param name="options">Task <see cref="T:System.Threading.Tasks.TaskCreationOptions"/> for the task. The default is <see cref="F:System.Threading.Tasks.TaskCreationOptions.RunContinuationsAsynchronously"/></param>
            <returns>An unstarted <see cref="T:System.Threading.Tasks.Task"/> proxy for the action.</returns>
        </member>
        <member name="M:Jcd.Tasks.UnstartedTask.Create(System.Func{System.Threading.Tasks.Task},System.Nullable{System.Threading.CancellationToken},System.Threading.Tasks.TaskCreationOptions)">
            <summary>
            Creates an unstarted <see cref="T:System.Threading.Tasks.Task"/> as a proxy for an asynchronous action. Once started the task will execute the action. 
            </summary>
            <param name="action"></param>
            <param name="cancellationToken">The optional cancellation token for the task. The default is <see langword="null"/>.</param>
            <param name="options">Task <see cref="T:System.Threading.Tasks.TaskCreationOptions"/> for the task. The default is <see cref="F:System.Threading.Tasks.TaskCreationOptions.RunContinuationsAsynchronously"/></param>
            <returns>An unstarted <see cref="T:System.Threading.Tasks.Task"/> proxy for the asynchronous action.</returns>
        </member>
        <member name="M:Jcd.Tasks.UnstartedTask.Create``1(System.Func{``0},System.Nullable{System.Threading.CancellationToken},System.Threading.Tasks.TaskCreationOptions)">
            <summary>
            Creates an unstarted <see cref="T:System.Threading.Tasks.Task`1"/> as a proxy for a function. Once started the task will execute the function.
            </summary>
            <param name="function">The function to execute.</param>
            <param name="cancellationToken">The optional cancellation token for the task. The default is <see langword="null"/>.</param>
            <param name="options">Task <see cref="T:System.Threading.Tasks.TaskCreationOptions"/> for the task. The default is <see cref="F:System.Threading.Tasks.TaskCreationOptions.RunContinuationsAsynchronously"/></param>
            <returns>An unstarted <see cref="T:System.Threading.Tasks.Task`1"/> proxy for the function.</returns>
            <typeparam name="TResult">The type of the data returned.</typeparam>
        </member>
        <member name="M:Jcd.Tasks.UnstartedTask.Create``1(System.Func{System.Threading.Tasks.Task{``0}},System.Nullable{System.Threading.CancellationToken},System.Threading.Tasks.TaskCreationOptions)">
            <summary>
            Creates an unstarted <see cref="T:System.Threading.Tasks.Task`1"/> as a proxy for an asynchronous function. Once started the task will execute the function.
            </summary>
            <param name="function"></param>
            <param name="cancellationToken">The optional cancellation token for the task. The default is <see langword="null"/>.</param>
            <param name="options">Task <see cref="T:System.Threading.Tasks.TaskCreationOptions"/> for the task. The default is <see cref="F:System.Threading.Tasks.TaskCreationOptions.RunContinuationsAsynchronously"/></param>
            <returns>An unstarted <see cref="T:System.Threading.Tasks.Task`1"/> proxy for the asynchronous function.</returns>
            <typeparam name="TResult">The type of the data returned.</typeparam>
        </member>
    </members>
</doc>
